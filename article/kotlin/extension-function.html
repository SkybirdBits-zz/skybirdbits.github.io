<!DOCTYPE html>
<html lang="fa">
<head>
    <meta content="ie=edge" http-equiv="x-ua-compatible"/>
    <meta content="برنامه نویسی کاتلین، اکستنشن فانکشن ، extension function ، extension property ، اکشتنشن پروپرتی ، برنامه نویسی تابعی"
          name="keywords"/>
    <meta content="توابع اکشتنشن و property ها در کاتلین" name="description"/>
    <meta charset="UTF-8"/>
    <meta content="width:device-width, initial-scale=1" name="viewport"/>

    <title>اکستنشن ها در کاتلین</title>

    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css"
          rel="stylesheet">
    <link crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/css/bootstrap.min.css"
          integrity="sha384-Zenh87qX5JnK2Jl0vWa8Ck2rdkQ2Bzep5IDxbcnCeuOxjzrPF/et3URy9Bv1WTRi" rel="stylesheet"/>

    <link href="/resources/css/main.css" rel="stylesheet">
    <link href="/resources/favicon.png" rel="icon" type="image/x-icon">


    <script crossorigin="anonymous"
            integrity="sha256-o88AwQnZB+VDvE9tvIXrMQaPlFFSUTR+nldQm1LuPXQ="
            src="https://code.jquery.com/jquery-3.6.1.min.js"></script>

    <script type="text/javascript" src="/resources/js/main.js"></script>


</head>
<body>

<div class="container-fluid content">

    <div class="page-wrap">


        <header class="article-header">
            <h1>
                اکستنشن ها در کاتلین
            </h1>

            <address>
                <a class="author text-muted text-decoration-none" rel="author">یونس سلیمانی</a>
            </address>

            <figure class="figure figure-wrapper">
                <img alt="تابع اکستنشن در کاتلین"
                     class="rounded figure-img"
                     src="/resources/image/kotlin/extension_functions_cover.png">
            </figure>

        </header>

        <article>

            <p>
                <strong>
                    توجه: در این مطلب فرض شده با مبانی شی گرایی و توابع (متدها) در کاتلین آشنایی دارید
                </strong>
            </p>


            <p>
                <strong>
                    تعریف Extension در کاتلین:
                </strong>
                اضافه کردن property یا function خارج از کلاس به کلاس بدون دستکاری خود کلاس.
                اکستنشن ها تغییری در کلاس ایجاد نمیکنن و مانند property و function های داخل کلاس اونا رو صدا می‌زنیم

            </p>

            <p>
                <strong>
                    در کاتلین سه نوع extension داریم:
                </strong>
            </p>

            <h3>
                1- تابع اکستنشن:
            </h3>

            <blockquote>
                به توابعی گفته میشه که اضافه بر توابع خود کلاس، در خارج از کلاس تعریف میکنیم و برای صدا زدنشون مثل توابع
                داخل کلاس صداشون می‌زنیم
            </blockquote>

            <p>
                فرم کلی:
            </p>

            <pre>
                <code>
    fun &lt;T&gt; MyClass&lt;T&gt;.myFunction(...){

        ....

    }
                </code>
            </pre>


            <p>
                در اینجا MyClass اسم کلاس مورد نظر است یه نقطه میزاریم سپس اسم دلخواه برای تابعمون مینویسیم و مثل
                function معمولی پارامتر های دلخواه داخل پرانتز function رو تعریف میکنیم همینطور اگه برای کلاس Generic
                تعریف شده بود مانند بالا میتونیم برای تابعی که تعریف میکنیم Generic هم تعریف کنیم تا برای هر نوع متغیری
                قابل استفاده باشه
            </p>

            <p>
                برای صدا زدن Extension Function ها مثل توابع معمولی عمل میکنیم
            </p>

            <pre>
                <code>
    val myClass = MyClass&lt;T&gt;()
    myClass.myFunction(...)
                </code>
            </pre>

            <p>
                <strong>
                    مثال:
                </strong>
            </p>

            <pre>
                <code>
    fun String.isPalindrome(): Boolean{
       return if (length <= 1) true
        else if (this[0] != this[length -1]) false
        else substring(1, length -1).isPalindrome()
    }
                </code>

                <code>
    fun main(){
      val s0 = "moon"
      val s1 = "noon"
      val s2 = "abf"
      val s3 = "aba"

      println("is $s0 palindrome? ${s0.isPalindrome()}")
      println("is $s1 palindrome? ${s1.isPalindrome()}")
      println("is $s2 palindrome? ${s2.isPalindrome()}")
      println("is $s3 palindrome? ${s3.isPalindrome()}")
    }
                </code>
            </pre>

            <p>
                در مثال بالا یک function به کلاس String اضافه کردیم که بررسی میکنه یک String متقارن است یا خیر
            </p>

            <p>
                <strong>
                    نکته ها:
                </strong>
            </p>


            <p>
                ۱- این توابع کلاس رو دستکاری نمیکنن و با تعریف کردنشون عضوی به اعضای داخل کلاس اضافه نمیشه
            </p>

            <p>
                ۲- داخل این توابع با کلید واژه ی this میتونیم به نمونه کلاس و اعضای کلاس دسترسی داشته باشیم
            </p>

            <p>
                ۳- اگه این توابع با یکی از توابع داخل کلاس از نظر پارامتر و اسم یکی باشن هنگام صدا زدن، تابع داخل کلاس
                به اجرا در میاد
            </p>


            <h3>
                2- Extension Property:
            </h3>

            <p>
                فرم کلی:
            </p>

            <pre>
                <code>
    val &lt;T&gt; MyClass&lt;T&gt;.myProperty: Int
        get(){...}
                </code>
            </pre>

            <p>
                کاملا شبیه extension function هاست extension property ها نمی‌تونن دارای مقدار اولیه باشن همون‌طور که
                بالا گفتیم extension ها ربطی به کلاس ندارن پس مقدار اولیه ای برای extension property ها وجود نداره
            </p>

            <p>
                <strong>مثال:</strong>
            </p>

            <pre>
                <code>
    val Int.even: Boolean get(){
        return this % 2 == 0
    }

    fun main(){
      val num0 = 24
      val num1 = 7

      println("is $num0 even? ${num0.even}")
      println("is $num1 even? ${num1.even}")
    }
                </code>
            </pre>

            <p>
                در بالا یک property به کلاس Int اضافه کردیم که بررسی میکنه عدد زوجه یا نه
            </p>


            <h3>
                3- Companion Object Extension:
            </h3>


            <p>
                اگه کلاسی داری Companion object باشه میتونیم Extension ها رو به صورت Companion تعریف کنیم:
            </p>

            <pre>
                <code>
    MyClass.Companion.myFunction(){

    //...

    }
                </code>
            </pre>


            <p>
                برای صدا زدنش مثل بقیه اعضای داخل companion object عمل میکنیم:
            </p>


            <pre>
                <code>
    MyClass.myFunction()
                </code>
            </pre>


            <h2>خلاصه:</h2>


            <p>
                در کاتلین Extension ها تاثیری روی کلاس ندارن وقتی برای یک کلاس extension تعریف میکنیم فقط بیان میکنیم که
                function یا property تعریف شده رو باید با استفاده از متغیر کلاس صدا بزنیم

                برای صدا زدن extension ها مانند اعضای داخل کلاس باید اسم متغیر کلاس نقطه و اسم function یا property
                تعریف شده رو بنویسیم
            </p>


            <p>
                در قطعه کد زیر به طور خلاصه از هر سه نوع یک نمونه بیان شده است
            </p>


            <pre>
                <code>
    //Extension Function
    fun MyClass.myExtensionFunction(){
        //...
    }

    //Extension Property
    val MyClass.myExtensionProperty: List&lt;String&gt; get(){
        //...
    }

    //Companion object extension
    fun MyClass.Companion.myExtensionCompanionFunction(){
        //...
    }

    val myObject = MyClass()

    myObject.myExtensionFunction()

    val list = myObject.myExtensionProperty

    MyClass.myExtensionCompanionFunction()
                </code>
            </pre>


            <p>
                خب با Extension ها در کاتلین آشنا شدیم امیدوارم براتون مفید باشه وقت بخیر 🌸
            </p>

        </article>

    </div>

    <div id="footer_container" >
    </div>
</div>

</body>
</html>